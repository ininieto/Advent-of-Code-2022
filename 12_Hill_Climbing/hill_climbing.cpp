#include <iostream>
#include <vector>
#include <unordered_map>
#include <fstream>

/*
    Advent of Code 2022 - 12.12.2022

    Link to the problem: https://adventofcode.com/2022/day/12

    Author of the solution: Íñigo Nieto Cuadrado

*/

// Piece of code needed to create a Hashmap with a std::pair as the key (Generated by ChatGPT lol)
namespace std {
    template <>
    struct hash<std::pair<int, int>> {  // Even ChatGPT places the keys here :) 
        size_t operator()(const std::pair<int, int>& p) const {
            // Use a hash function combining the two integers
            size_t h1 = std::hash<int>{}(p.first);
            size_t h2 = std::hash<int>{}(p.second);
            // Combine the hashes using a bitwise operation (e.g., XOR)
            return h1 ^ h2;
        }
    };
}

std::string readInputText(std::string inputText){

    // Read input data from txt file
    std::fstream inputfile;
    std::string inputData;

    inputfile.open(inputText, std::ios::in);
    if (inputfile.is_open()){
        std::string tp;
        while (getline(inputfile, tp)){
            inputData += tp;
            inputData += "\n";
        }
    }
    return inputData;
}

std::vector<std::pair<int, int>> getSurroundings(std::pair<int, int> position, int nrows, int ncols){

    std::vector<std::pair<int, int>> surroundings;

    std::pair<int, int> up = std::make_pair(position.first - 1, position.second);
    std::pair<int, int> down = std::make_pair(position.first + 1, position.second);
    std::pair<int, int> left = std::make_pair(position.first, position.second - 1);
    std::pair<int, int> right = std::make_pair(position.first, position.second + 1);

    if(position == std::make_pair(0, 0)){   // Top left corner
        
        surroundings.push_back(right); // rightElement = rows[right.first][right.second];
        surroundings.push_back(down); // downElement = rows[down.first][down.second];
        
    }
    else if(position == std::make_pair(0, ncols - 1)){  // Top right corner

        surroundings.push_back(left); // leftElement = rows[left.first][left.second];
        surroundings.push_back(down); // downElement = rows[down.first][down.second];

    }
    else if(position == std::make_pair(nrows - 1, 0)){  // Bottom left corner

        surroundings.push_back(right); // rightElement = rows[right.first][right.second];
        surroundings.push_back(up); // upElement = rows[up.first][up.second];

    }
    else if(position == std::make_pair(nrows - 1, ncols - 1)){  // Bottom right corner

        surroundings.push_back(left); // leftElement = rows[left.first][left.second];
        surroundings.push_back(up); // upElement = rows[up.first][up.second];

    }
    else if(position.first == 0){   // First row

        surroundings.push_back(left); // leftElement = rows[left.first][left.second];
        surroundings.push_back(right); // rightElement = rows[right.first][right.second];
        surroundings.push_back(down); // downElement = rows[down.first][down.second];

    }
    else if(position.first == nrows - 1){   // Last row

        surroundings.push_back(left); // leftElement = rows[left.first][left.second];
        surroundings.push_back(right); // rightElement = rows[right.first][right.second];
        surroundings.push_back(up); // upElement = rows[up.first][up.second];

    }
    else if(position.second == 0){  // First column

        surroundings.push_back(right); // rightElement = rows[right.first][right.second];
        surroundings.push_back(up); // upElement = rows[up.first][up.second];
        surroundings.push_back(down); // downElement = rows[down.first][down.second];

    }
    else if(position.second == ncols - 1){   // Last column

        surroundings.push_back(left); // leftElement = rows[left.first][left.second];
        surroundings.push_back(up); // upElement = rows[up.first][up.second];
        surroundings.push_back(down); // downElement = rows[down.first][down.second];

    }
    else{   // No weird cases
        surroundings.push_back(right); // rightElement = rows[right.first][right.second];
        surroundings.push_back(left); // leftElement = rows[left.first][left.second];
        surroundings.push_back(up); // upElement = rows[up.first][up.second];
        surroundings.push_back(down); // downElement = rows[down.first][down.second];
    }

    return surroundings;
}

std::pair<int, int> jump(std::pair<int, int> position, std::vector<std::pair<int, int>> surroundings, std::vector<std::vector <int>> rows, std::unordered_map<std::pair<int, int>, bool> checkedPositions){

    std::vector<int> surroundingElements;
    std::vector<std::pair<int, int>> possibleJumps;
    int currentElement = rows[position.first][position.second];

    for(auto e : surroundings){
        if((rows[e.first][e.second] == currentElement || rows[e.first][e.second] == currentElement + 1) && checkedPositions.find(e) == checkedPositions.end()){  // We can only jump to the same value or 1 higher
            surroundingElements.push_back(rows[e.first][e.second]);
            possibleJumps.push_back(e);
        }
    }

    // Get the highest value of the possible surroundings --> will be the jump

    int highestValue = 0;

    for(auto e : surroundingElements){
        if(e > highestValue)
            highestValue = e;
    }

    // return the position associated to the highest value

    for(auto e : possibleJumps){
        if(rows[e.first][e.second] == highestValue)
            return e;
    }

    return position; // Should never reach this, but warning is annoying
}

int main(){

    const int nrows = 5, ncols = 8; 
    int jumps = 0;

    std::string example = "Sabqponm\nabcryxxl\naccszExk\nacctuvwj\nabdefghi\n";
    std::vector<std::vector <int>> rows(nrows, std::vector<int>(ncols));
    std::pair position(0, 0), endPosition(-1, -1);

    // Fill in the rows and cols vectors with the ascii values of the characters
    int stringCount = 0;

    for(int i = 0; i < nrows; i++){
        for(int j = 0; j < ncols; j++){

            if(example[stringCount] == '\n')
                stringCount ++;

            if(example[stringCount] == 'S'){
                position = std::make_pair(i, j);
                rows[i][j] = int('a') - 1;
                stringCount ++;
                continue;
            }
                
            if(example[stringCount] == 'E'){
                endPosition = std::make_pair(i, j);
                rows[i][j] = int('z') + 1;
                stringCount ++;
                continue;
            }
            rows[i][j] = int(example[stringCount]);
            stringCount ++;
        }
    }

    // TODO: Investigate if Dijkstra could be interesting 

    std::unordered_map<std::pair<int, int>, bool> checkedPositions;
    checkedPositions[position] = true;

    // Main loop
    while(position != endPosition){

        // Store in a vector all the surroundings
        std::vector<std::pair<int, int>> surroundings = getSurroundings(position, nrows, ncols);

        // Check the surroundings and decide a jump
        position = jump(position, surroundings, rows, checkedPositions);
        jumps ++;
        checkedPositions[position] = true;

        std::cout << "I'm in position " << position.first << ", " << position.second << '\n';
    }

    std::cout << jumps << " jumps" << '\n';

    return 0;
}