/*
    Advent of Code 2022 - 09.12.2022

    Link to the problem: https://adventofcode.com/2022/day/9

    Author of the solution: Íñigo Nieto Cuadrado

*/

#include <iostream>
#include <unordered_map>
#include <fstream>

// Piece of code needed to create a Hashmap with a std::pair as the key (Generated by ChatGPT lol)
namespace std {
    template <>
    struct hash<std::pair<int, int>> {  // Even ChatGPT places the keys here :) 
        size_t operator()(const std::pair<int, int>& p) const {
            // Use a hash function combining the two integers
            size_t h1 = std::hash<int>{}(p.first);
            size_t h2 = std::hash<int>{}(p.second);
            // Combine the hashes using a bitwise operation (e.g., XOR)
            return h1 ^ h2;
        }
    };
}

// Read input data from txt file
std::string readInputText(std::string inputText){

    std::fstream inputfile;
    std::string inputData;

    inputfile.open(inputText, std::ios::in);
    if (inputfile.is_open()){
        std::string tp;
        while (getline(inputfile, tp)){
            inputData += tp;
            inputData += "\n";
        }
    }

    return inputData;
}

void moveHead(std::pair<int, int> &headPosition, std::pair<int, int> movement) {
        headPosition.first += movement.first;
        headPosition.second += movement.second;
}

void moveTail(std::pair<int, int> &tailPosition, std::pair<int, int> &headPosition, std::pair<int, int> headMovement, std::unordered_map<std::pair<int, int>, int> &visitedTailSpots){

    bool touching = (abs(headPosition.first - tailPosition.first) == 1 && abs(headPosition.second - tailPosition.second) == 0) || // X axis
                    (abs(headPosition.first - tailPosition.first) == 0 && abs(headPosition.second - tailPosition.second) == 1) || // Y axis
                    (abs(headPosition.first - tailPosition.first) == 1 && abs(headPosition.second - tailPosition.second) == 1) || // Diagonal
                    (abs(headPosition.first - tailPosition.first) == 0 && abs(headPosition.second - tailPosition.second) == 0);   // Same position

    bool sameLine = (abs(headPosition.first - tailPosition.first) == 2 && abs(headPosition.second - tailPosition.second) == 0) || // X axis
                    (abs(headPosition.first - tailPosition.first) == 0 && abs(headPosition.second - tailPosition.second) == 2);   // Y axis


    if(touching){
        visitedTailSpots[tailPosition] = 1;
        return;
    }
    else if(sameLine){
        tailPosition.first += headMovement.first;
        tailPosition.second += headMovement.second;
    }
    else{   // If they are not in the same line

        // I need to jump in diagonal. I will always jump in the same direction as the head,
        // and also in the perpendicular direction to reach closer

        if (headMovement.first == 0){ // If Head moving in Y direction

            if (headPosition.first > tailPosition.first)
                tailPosition.first++;
            else
                tailPosition.first--;
        }
        else{ // If Head moving in X direction

            if (headPosition.second > tailPosition.second) // If head is upper than tail
                tailPosition.second++;
            else
                tailPosition.second--;
        }

        // Move like the head
        tailPosition.first += headMovement.first;
        tailPosition.second += headMovement.second;
    }

    visitedTailSpots[tailPosition] = 1; // Don't really need to check if it already exists. We don't wanna count how many times every spot is gone through, but only yes/no. We can simply rewrite
}

int main(){

    std::pair<int, int> headPosition(0, 0), tailPosition(0, 0);                          // Pairs containing the coordinates X, Y of the head and tail
    std::pair<int, int> moveRight(1, 0), moveLeft(-1, 0), moveUp(0, 1), moveDown(0, -1); // Pairs defining the possible movements

    std::unordered_map<char, std::pair<int, int>> movementDict = {{'R', moveRight}, {'L', moveLeft}, {'U', moveUp}, {'D', moveDown}}; // Map association between the letter and the movement
    std::unordered_map<std::pair<int, int>, int> visitedTailSpots;                                                                    // Map that will contain all the visited spots. In principle, std::pair is not hashable. Must define by hand the hash operation 

    std::string example = "R 4\nU 4\nL 3\nD 1\nR 4\nD 1\nL 5\nR 2\n";
    std::string inputData = readInputText("input.txt");
    std::string line;

    for(char c : inputData){    // Iterate all over the instructions

        if(c != '\n')
            line.push_back(c);
        else{
            char direction = line[0];
            int numSteps = stoi(line.substr(2, line.length()));

            std::pair <int, int> headMovement = movementDict[direction];

            for(int i = 0; i < numSteps; i++){

                moveHead(headPosition, headMovement);
                moveTail(tailPosition, headPosition, headMovement, visitedTailSpots);
                // std::cout << "HEAD X: " << headPosition.first << "  Y: " << headPosition.second << std::endl;
                // std::cout << "TAIL X: " << tailPosition.first << "  Y: " << tailPosition.second << std::endl << std::endl;
            }

            line.clear();
        }
    }

    std::cout << "The solution is " << visitedTailSpots.size() << std::endl;

    return 0;
}