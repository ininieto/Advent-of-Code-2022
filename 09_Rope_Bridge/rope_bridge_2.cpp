/*
    Advent of Code 2022 - 09.12.2022

    Link to the problem: https://adventofcode.com/2022/day/9

    Author of the solution: Íñigo Nieto Cuadrado

*/

#include <iostream>
#include <unordered_map>
#include <vector>
#include <fstream>

// Piece of code needed to create a Hashmap with a std::pair as the key (Generated by ChatGPT lol)
namespace std {
    template <>
    struct hash<std::pair<double, double>> {  // Even ChatGPT places the keys here :) 
        size_t operator()(const std::pair<double, double>& p) const {
            // Use a hash function combining the two integers
            size_t h1 = std::hash<double>{}(p.first);
            size_t h2 = std::hash<double>{}(p.second);
            // Combine the hashes using a bitwise operation (e.g., XOR)
            return h1 ^ h2;
        }
    };
}

// Read input data from txt file
std::string readInputText(std::string inputText){

    std::fstream inputfile;
    std::string inputData;

    inputfile.open(inputText, std::ios::in);
    if (inputfile.is_open()){
        std::string tp;
        while (getline(inputfile, tp)){
            inputData += tp;
            inputData += "\n";
        }
    }

    return inputData;
}

void moveHead(std::pair<double, double> &headPosition, std::pair<double, double> movement) {
        headPosition.first += movement.first;
        headPosition.second += movement.second;
}

void moveTail(std::pair<double, double> &tailPosition, std::pair<double, double> &headPosition, std::unordered_map<std::pair<double, double>, double> &visitedTailSpots, double tailIndex){

    // Too spaghetti, I can do it better

    bool touching = (abs(headPosition.first - tailPosition.first) == 1 && abs(headPosition.second - tailPosition.second) == 0) || // X axis
                    (abs(headPosition.first - tailPosition.first) == 0 && abs(headPosition.second - tailPosition.second) == 1) || // Y axis
                    (abs(headPosition.first - tailPosition.first) == 1 && abs(headPosition.second - tailPosition.second) == 1) || // Diagonal
                    (abs(headPosition.first - tailPosition.first) == 0 && abs(headPosition.second - tailPosition.second) == 0);   // Same position

    bool sameLineX = abs(headPosition.first - tailPosition.first) == 2 && abs(headPosition.second - tailPosition.second) == 0;    // X axis
    bool sameLineY = abs(headPosition.first - tailPosition.first) == 0 && abs(headPosition.second - tailPosition.second) == 2;   // Y axis

    if (touching){
        if (tailIndex == 9)
            visitedTailSpots[tailPosition] = 1;
        return;
    }
    else if (sameLineX){
        if(headPosition.first > tailPosition.first)
            tailPosition.first ++;
        else 
            tailPosition.first --;
    }
    else if (sameLineY){
        if(headPosition.second > tailPosition.second)
            tailPosition.second ++;
        else 
            tailPosition.second --;
    }
    else{ // If they are not in the same line --> Diagonal jump

        if (headPosition.first > tailPosition.first){
            if (headPosition.second > tailPosition.second){ // Right and Up
                tailPosition.first ++;
                tailPosition.second ++;
            }
            else{
                tailPosition.first ++; // Right and Down
                tailPosition.second --;
            }
        }
        else{
            if (headPosition.second > tailPosition.second){ // Left and Up
                tailPosition.first --;
                tailPosition.second ++;
            }
            else{
                tailPosition.first --; // Left and Down
                tailPosition.second --;
            }
        }
    }

    if(tailIndex == 9)
        visitedTailSpots[tailPosition] = 1; // Don't really need to check if it already exists. We don't wanna count how many times every spot is gone through, but only yes/no. We can simply rewrite
}

int main(){

    const double numKnots = 10;
    std::vector<std::pair<double, double>> knots(numKnots);                                    // Pairs containing the coordinates X, Y of all the knots
    std::pair<double, double> moveRight(1, 0), moveLeft(-1, 0), moveUp(0, 1), moveDown(0, -1); // Pairs defining the possible movements

    std::unordered_map<char, std::pair<double, double>> movementDict = {{'R', moveRight}, {'L', moveLeft}, {'U', moveUp}, {'D', moveDown}}; // Map association between the letter and the movement
    std::unordered_map<std::pair<double, double>, double> visitedTailSpots;                                                                    // Map that will contain all the visited spots. In principle, std::pair is not hashable. Must define by hand the hash operation 

    std::string example = "R 4\nU 4\nL 3\nD 1\nR 4\nD 1\nL 5\nR 2\n";
    std::string largerExample = "R 5\nU 8\nL 8\nD 3\nR 17\nD 10\nL 25\nU 20\n";
    std::string inputData = readInputText("input.txt");
    std::string line;

    for(char c : inputData){    // Iterate all over the instructions

        if(c != '\n')
            line.push_back(c);
        else{
            char direction = line[0];
            double numSteps = stoi(line.substr(2, line.length()));

            std::pair <double, double> headMovement = movementDict[direction];

            for(double i = 0; i < numSteps; i++){

                for(double j = 0; j < numKnots - 1; j++){

                    (j == 0) ? moveHead(knots[j], headMovement) : moveTail(knots[j], knots[j - 1], visitedTailSpots, j);
                    moveTail(knots[j + 1], knots[j], visitedTailSpots, j + 1);
                }
            }
            line.clear();
        }
    }

    std::cout << "The solution is " << visitedTailSpots.size() << std::endl;

    return 0;
}